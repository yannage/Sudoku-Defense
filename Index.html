<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Tower Defense</title>
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <h1>Sudoku Tower Defense</h1>
    
    <div id="game-container">
        <div id="game-header">
            <div id="score">Score: <span id="score-value">0</span></div>
            <div id="lives">Lives: <span id="lives-value">3</span></div>
            <div id="wave">Wave: <span id="wave-value">1</span></div>
        </div>
        
        <div id="sudoku-board"></div>
        
        <div id="tower-selection">
            <div class="tower-option" data-tower-type="1" title="Number Tower (1): Attacks enemies with matching number">1Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="2" title="Number Tower (2): Attacks enemies with matching number">2Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="3" title="Number Tower (3): Attacks enemies with matching number">3Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="4" title="Number Tower (4): Attacks enemies with matching number">4Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="5" title="Number Tower (5): Attacks enemies with matching number">5Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="6" title="Number Tower (6): Attacks enemies with matching number">6Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="7" title="Number Tower (7): Attacks enemies with matching number">7Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="8" title="Number Tower (8): Attacks enemies with matching number">8Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="9" title="Number Tower (9): Attacks enemies with matching number">9Ô∏è‚É£</div>
            <div class="tower-option" data-tower-type="special" title="Special Tower: Attacks all enemy types">üîÆ</div>
        </div>
        
        <div id="game-info">
            <div>Currency: <span id="currency-value">100</span></div>
            <div id="status-message">Place towers to defend against enemies!</div>
        </div>
        
        <div id="game-controls">
            <button id="start-wave">Start Wave</button>
            <button id="pause-game">Pause</button>
            <button id="new-game">New Game</button>
        </div>
    </div>

    <!-- Load the modules in the correct order -->
    <script src="js/events.js"></script>
    <script src="js/sudoku.js"></script>
    <script src="js/player.js"></script>
    <script src="js/enemies.js"></script>
    <script src="js/towers.js"></script>
    <script src="js/save-system.js"></script>
    <script src="js/levels.js"></script>
    <script src="js/game.js"></script>
    
    <!-- Enemy positioning fix scripts -->
    <script>
    // Direct enemy position fix
    (function() {
        console.log("Applying direct enemy position fix");
        
        // Function to check if a module is loaded
        function checkModuleLoaded(interval, moduleName, callback) {
            if (window[moduleName]) {
                callback();
            } else {
                setTimeout(function() {
                    checkModuleLoaded(interval, moduleName, callback);
                }, interval);
            }
        }
        
        // Fix enemy position issue directly
        function applyEnemyFix() {
            console.log("EnemiesModule found, applying fix");
            
            // Get the original createEnemy function
            const originalCreateEnemy = EnemiesModule.createEnemy;
            
            // Replace it with our fixed version
            EnemiesModule.createEnemy = function(type) {
                // Get the board element to calculate exact cell size
                const boardElement = document.getElementById('sudoku-board');
                const currentCellSize = boardElement ? boardElement.clientWidth / 9 : 55;
                
                // Get current path directly from SudokuModule
                const currentPath = SudokuModule.getPathArray();
                
                // Make sure path exists
                if (!currentPath || !currentPath.length) {
                    console.error("No path available for enemy creation");
                    // Try to regenerate the path
                    SudokuModule.generateEnemyPath();
                    return null;
                }
                
                // Call the original function to create the enemy
                const enemy = originalCreateEnemy.call(this, type);
                
                // Make sure enemy was created
                if (!enemy) return null;
                
                // Force the correct position based on the current path
                const startCell = currentPath[0];
                enemy.x = startCell[1] * currentCellSize + currentCellSize / 2;
                enemy.y = startCell[0] * currentCellSize + currentCellSize / 2;
                
                console.log(`Enemy ${enemy.id} positioned at (${enemy.x}, ${enemy.y})`);
                
                return enemy;
            };
            
            // Fix the update function
            const originalUpdate = EnemiesModule.update;
            EnemiesModule.update = function(deltaTime) {
                // Check if enemy container exists
                if (!document.getElementById('enemy-container')) {
                    // Create enemy container if it doesn't exist
                    const boardElement = document.getElementById('sudoku-board');
                    if (boardElement) {
                        const container = document.createElement('div');
                        container.id = 'enemy-container';
                        container.style.position = 'absolute';
                        container.style.top = '0';
                        container.style.left = '0';
                        container.style.width = '100%';
                        container.style.height = '100%';
                        container.style.pointerEvents = 'none';
                        container.style.zIndex = '50';
                        boardElement.appendChild(container);
                        console.log("Created missing enemy container");
                    }
                }
                
                // Call original update
                originalUpdate.call(this, deltaTime);
            };
            
            console.log("Enemy position fix applied successfully!");
        }
        
        // Wait for modules to load
        checkModuleLoaded(100, 'EnemiesModule', function() {
            checkModuleLoaded(100, 'SudokuModule', function() {
                applyEnemyFix();
            });
        });
    })();
    </script>
    
    <script>
    // Enemy rendering fix
    (function() {
        console.log("Applying enemy rendering fix");
        
        // Wait for DOM content loaded
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(fixEnemyRendering, 500);
        });
        
        function fixEnemyRendering() {
            // Make sure Game object is available
            if (!window.Game) {
                console.log("Game not available yet, retrying in 500ms");
                setTimeout(fixEnemyRendering, 500);
                return;
            }
            
            console.log("Fixing enemy rendering");
            
            // Get the board element
            const boardElement = document.getElementById('sudoku-board');
            if (!boardElement) {
                console.error("Board element not found");
                return;
            }
            
            // Create a completely new enemy container
            let enemyContainer = document.getElementById('enemy-container');
            if (enemyContainer) {
                // Remove existing container
                enemyContainer.remove();
            }
            
            // Create a new container
            enemyContainer = document.createElement('div');
            enemyContainer.id = 'enemy-container';
            enemyContainer.style.position = 'absolute';
            enemyContainer.style.top = '0';
            enemyContainer.style.left = '0';
            enemyContainer.style.width = '100%';
            enemyContainer.style.height = '100%';
            enemyContainer.style.pointerEvents = 'none';
            enemyContainer.style.zIndex = '50';
            
            // Add a border for debugging (uncomment if needed)
            // enemyContainer.style.border = '1px dashed red';
            
            // Append to board
            boardElement.appendChild(enemyContainer);
            
            console.log("Created new enemy container");
            
            // Replace the Game.renderEnemies function
            if (typeof Game.renderEnemies === 'function') {
                const originalRenderEnemies = Game.renderEnemies;
                
                Game.renderEnemies = function() {
                    // Only replace if not already replaced
                    if (this._fixedRenderEnemies) {
                        return originalRenderEnemies.call(this);
                    }
                    
                    // Get all enemies
                    const enemies = EnemiesModule.getEnemies();
                    if (!enemies || !enemies.length) {
                        return; // No enemies to render
                    }
                    
                    // Make sure enemy container exists
                    let container = document.getElementById('enemy-container');
                    if (!container) {
                        // Create container if it doesn't exist
                        container = document.createElement('div');
                        container.id = 'enemy-container';
                        container.style.position = 'absolute';
                        container.style.top = '0';
                        container.style.left = '0';
                        container.style.width = '100%';
                        container.style.height = '100%';
                        container.style.pointerEvents = 'none';
                        container.style.zIndex = '50';
                        boardElement.appendChild(container);
                        console.log("Created enemy container during render");
                    }
                    
                    // Render each enemy
                    enemies.forEach(enemy => {
                        // Skip if position is 0,0 (indicates a problem)
                        if (enemy.x === 0 && enemy.y === 0) {
                            console.warn("Enemy at 0,0 position, skipping render");
                            return;
                        }
                        
                        let enemyElement = document.getElementById(enemy.id);
                        
                        if (!enemyElement) {
                            // Create new enemy element
                            enemyElement = document.createElement('div');
                            enemyElement.id = enemy.id;
                            enemyElement.className = 'enemy';
                            enemyElement.textContent = enemy.emoji;
                            container.appendChild(enemyElement);
                            
                            // Create health bar
                            const healthBar = document.createElement('div');
                            healthBar.className = 'enemy-health-bar';
                            healthBar.style.position = 'absolute';
                            healthBar.style.bottom = '-8px';
                            healthBar.style.left = '-10px';
                            healthBar.style.width = '20px';
                            healthBar.style.height = '4px';
                            healthBar.style.backgroundColor = 'rgba(51, 51, 51, 0.8)';
                            healthBar.style.borderRadius = '2px';
                            
                            const healthFill = document.createElement('div');
                            healthFill.className = 'enemy-health-fill';
                            healthFill.style.width = '100%';
                            healthFill.style.height = '100%';
                            healthFill.style.backgroundColor = '#ff0000';
                            
                            healthBar.appendChild(healthFill);
                            enemyElement.appendChild(healthBar);
                            
                            console.log(`Created enemy ${enemy.id} at (${enemy.x}, ${enemy.y})`);
                        }
                        
                        // Position the enemy
                        enemyElement.style.transform = `translate3d(${enemy.x}px, ${enemy.y}px, 0)`;
                        
                        // Update health bar
                        const healthFill = enemyElement.querySelector('.enemy-health-fill');
                        if (healthFill) {
                            const healthPercent = (enemy.health / enemy.maxHealth) * 100;
                            healthFill.style.width = `${healthPercent}%`;
                        }
                    });
                    
                    // Remove any enemies that no longer exist
                    const enemyElements = container.querySelectorAll('.enemy');
                    enemyElements.forEach(element => {
                        const id = element.id;
                        if (!enemies.find(e => e.id === id)) {
                            element.remove();
                        }
                    });
                };
                
                // Mark as fixed
                Game.renderEnemies._fixedRenderEnemies = true;
                
                console.log("Replaced renderEnemies function");
            } else {
                console.error("Game.renderEnemies function not found");
            }
            
            // Force a render
            if (Game.renderEnemies) {
                Game.renderEnemies();
            }
        }
    })();
    </script>
    
    <!-- Debugging helper script - shows current enemy positions in console -->
    <script>
    (function() {
        console.log("Adding enemy position debugging");
        
        // Wait until game starts
        setTimeout(function() {
            if (window.EnemiesModule && typeof EnemiesModule.getEnemies === 'function') {
                // Check current enemy positions
                setInterval(() => {
                    const enemies = EnemiesModule.getEnemies();
                    if (enemies.length > 0) {
                        console.log("Enemy positions:", enemies.map(e => [e.id, e.x, e.y]));
                    }
                }, 5000); // Log every 5 seconds
                
                console.log("Enemy position debugging active");
            }
        }, 3000);
    })();
    </script>
</body>
</html>